<div class="entry-content">
<p>For the longest time, I have always been taking the easy way when it comes to programming. What I mean by that is I hardly took the time to explore and learn new ways to solve problems,&nbsp; I always applied the same methods which I was most comfortable with just so that I could finish the project faster. It has become apparent to me this way of coding is not only boring, but also it makes it very hard for me to improve. So I decided to take a different approach for my most recent project, and the result has been quite rewarding. Although the project is not yet finished, but I have already came across questions which I never thought about.</p>
<p>To make a short summary of what I have been working on: it is a Silverlight application which allows the user to build dynamic SQL query based on 2 data tables given, in the back end I am using Linq to Objects to return the result list of objects based on the query given. The old Chen would have just one XMAL file and one C# code behind file. Then I realized in a select query for example (see picture below), what if the user wanted multiple criteria for the where clause (eg., where School != Ryerson AND Name != Chen).</p>
<p><a href="http://c9lu508.files.wordpress.com/2012/02/capture.png"><img title="Capture" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="Capture" src="http://c9lu508.files.wordpress.com/2012/02/capture_thumb.png" width="569" height="122"></a></p>
<p>Of course I could have solved the problem by writing repeated XMAL code that does the same thing, but I realized writing repeated code is never a good idea, so this time I made the where clause a separate class with separate XMAL file, so if the user ever decided to have multiple-criteria where clause, the program will dynamically generate an object of the Where class to handle each criteria. In addition, my program now also has separate class for each type of query (eg., Select, Update, Insert, Join), not only does this make the program a lot more organized, but it is also for the reason that there are many SQL queries consist of combinations of the ones I mentioned above (eg., Insert into Table1 (Name) Select Name From Table1 Where Name = Chen), so it is only logical to have them in separate classes, that way they can be put together in any order the user wish.</p>
<p>I also tried to make my program as generic as possible so that it is extensible. Even though right now I am only dealing with 2 types of objects: Contact and School. But I am going to pretend there are a lot more, and who knows there might be more in the future. Since I need to be able to query both types of objects, so I decided to make the ProcessSelectQuery class generic. And it is through doing this, I have came across a very important concept I never knew before – interface covariance.&nbsp; We all know that in object oriented programming, we can do something like this:</p>
<p><font face="Arial">Apple myApple = new Apple();</font></p>
<p><font face="Arial">Fruit myFruit = myApple;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*Here an object of type Apple has been placed into a variable of type Fruit – which is possible since apple derives from Fruit */</font></p>
<p align="left">So I was surprised to find out that the same cannot be applied to interface:</p>
<p align="left">IEnumerable&lt;Apple&gt; apples = new Apple[]{ apple1, apple2, apple3 }; //line 1</p>
<p align="left">IEnumerable&lt;Apple&gt; fruits = apples; //line 2: works fine</p>
<p align="left">fruits[2] = new Banana(); //line 3: does not work anymore.</p>
<p><font face="Arial">Before .NET 4.0, line 2 could not even work, that is because IEnumerable&lt;T&gt; was invariant ( meaning no typing relationship between the types IEnumerable&lt;Base&gt; and IEnumerable&lt;Derivied&gt;). However since then, Microsoft has made several of its generic interfaces (including IEnumerable) covariant:</font></p>
<p><font face="Arial">public interface IEnumerable&lt;<strong>out</strong> T&gt;: IEnumerable {}</font></p>
<p>The out keyword means that you promise the compiler to use the generic parameter only in output positions. So in my case, I was able to do something like this:</p>
<p>public class linqObject&lt;T&gt;<br>{&nbsp; <br>&nbsp;&nbsp;&nbsp; public static List&lt;T&gt; GetObjects()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (SelectQuery.selectedType == typeof(Contact))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return School.GetContacts() as List&lt;T&gt;;<em>&nbsp; /*although School.GetContacts() returns List&lt;Contact&gt;, but it works fine here before of covariance. */<br></em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; …..</p>
<p>}</p>
<p>However List&lt;T&gt;, just like IEumerable&lt;T&gt; is not contravariance (you cannot use T in an input position like a method parameter), therefore the following code would fail:</p>
<p>List&lt;linqObject&lt;T&gt;&gt; tempList = linqObject&lt;T&gt;.GetObjects() as List&lt;linqObject&lt;T&gt;&gt;;</p>
<p>tempList[0] = new Contact()<em> /* this would not work even though class Contact is derived from class linqObject.*/</em></p>
<p><font size="3">Taking the time to learn new programming techniques and apply them is very worth while in the long run, I have learned several other things throughout this whole process which I will talk about in my next blog.</font></p>
</div>