<p>Multithreaded programming is something I just started learning, really hope to do a project soon where I can apply my knowledge more fully, as it is such an important part of C# programming. Any time you are making an application, multithreading will come to play for making the application UI to be more responsive. Especially now that multiprocessor computers are becoming very common, learning multithreaded programming will allow the programmer to take advantage of the available computer power.</p>
<p>However multithreaded programming is not easy, programmers like me are not used to the idea that other threads in my program can also take part of how the program behaves. Thankfully since .NET Framework 4, multithreaded programming is greatly simplified by using concept of tasks rather than threads. Before we go into details about task, let’s first understand the concept of ThreadPool. The threads in the managed thread pool are background threads. This means that a ThreadPool thread will not keep an application running once the foreground threads have existed.&nbsp; QueueUserWorkItem is one example that uses thread pool, it queues a method&nbsp; for execution (the WaitCallBack parameter of the function represents the method to be executed once a thread pool thread becomes available).&nbsp; However the method is not able to receive data from the thread once it completes it execution. And once it finishes the execution, you cannot instruct it to perform some other task based on the result of the previous execution. Task provide these functionalities, at the same time it also uses thread pool threads, which allows tasks to reuse threads in the thread pool, which means often there are more tasks created than threads.</p>
<p>There are several ways of executing a method as a task.&nbsp; One way is by using the task constructor and call the task’s start method:</font></p>
<p>Task task = new Task(Action); //Action represents the code to execute in the task&nbsp; task.Start();</p>
<p>we can also access the result of the task using task.Result, which is a generic type&nbsp; that allows all different kinds of return value. In cases where return values are required, we use function delegate rather than Action delegate to represent the code to be executed in the task:
    Task&lt;TResult&gt;(Func&lt;TResult&gt;)</a></p>
<p>Another way of executing a method as a task is by using Task.Run(Action action). The Run method also accepts function delegate that allows the task to return a value, similar to what I mentioned by using the Task constructor. There is however an advantage of running the task by using the start method.</p>
<p>Task theTask =Task.Run(()=&gt; Console.WriteLine (theTask.Id));</p>
<p>The racing problem can be fixed by using the Task’s start method:</p>
<p>TasktheTask=null;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />
theTask = new Task(() =&gt;Console.WriteLine(theTask.Id));<br />
theTask.Start();</p>
<p>In this way, by the time main thread calls Start method of the newly created task , theTask already has a reference to the newly created instance, so accessing the task’s&nbsp; Id once the start method gets called will be thread safe.</p>
<p>Just when things start to get a little bit confusing, below is another way of executing a task:&nbsp;</p>
<p>Task.Factory.StartNew(Action action)</p>
<p>As you probably have guessed it, it also uses ThreadPool threads ( which are background threads). However when it comes to long running thread, it is better to not use thread pool thread. By using the option TaskCreationOption.LongRunning as part of the Task.Factory.StartNew parameter, we notify TPL that this task is long running so that the runtime will dedicate a thread for it that is outside of the thread pool. And this is one of the reasons that we use Task.Factory.StartNew rather than Task.Run, it gives us the flexibility to control TaskCreationOptions for how the task behaves. </p>
<p>Task.Run (someAciton) ;&nbsp;&nbsp; is exactly equivalent to :</p>
<p>Task.Factory.StartNew(someAction,<br />
&nbsp;&nbsp;&nbsp; CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);</p>
<p>As mentioned earlier, task also allows another task to be automatically executed when one completes. ContinueWith is a function that allows you to chain multiple tasks one after another. Since the ContinueWith function takes in another task to be executed, its signature is ContinueWith(Action&lt;Task&lt;T&gt;&gt;). Similarily, if the Task that is processed in the ContinueWith funciton also needs to return a value, then its signature becomes ContinueWith&lt;TResult&gt;(Func&lt;Task, Tresult&gt;).&nbsp; </p>
<p>Final note, ContinueWith function works with all 3 options of creating tasks I mentioned, guess it is up to you to decide which one is suitable.</p>